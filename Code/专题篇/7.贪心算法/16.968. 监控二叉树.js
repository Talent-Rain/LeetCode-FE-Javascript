// 968. 监控二叉树
// https://leetcode-cn.com/problems/binary-tree-cameras/

/**
 * @分析
 * 1. 这里要求尽可能少的安装摄像头，但是改装的还是得装上，需要全覆盖，那么最好的办法肯定是自底向上的装，因为层数越深，节点越多，所以自顶向上能减少摄像头的安装
 * 2. 那么现在要尽可能让摄像头覆盖到每一个节点，这里节点 val 作为状态值，0就是没有覆盖，1就是安装摄像头覆盖，2是没有安装但是在覆盖范围内
 * 3. 我们知道要尽可能的在有状态为 0 的叶子节点的 `父节点` 上去安装，这样就可以一次性覆盖到叶子节点，同时由于是自底向上的遍历，那么不需要考虑更底层的覆盖，只需要考虑当前节点和它的叶子节点即可
 * 4. 所以我们用后续遍历的方式进行后续遍历，当我们到达叶子节点时返回；
 * 5. 当我们遇到叶子节点都为不为 0，也就是都在覆盖范围内的时候，如果存在叶子节点状态为 1，即当前节点也属于覆盖范围，需要更改状态为 2， 然后 return 回去 -- 这里用到了贪心，也就是必须要有状态为 0 的叶子节点，才会去安装摄像头，保证摄像头的覆盖范围，进而保证数量最小
 * 6. 如果存在叶子节点的状态为 0，那么就必须在当前节点设置摄像头，也就将状态 root.val 设置为 1
 * 7. 当我们自低向上遍历到了根节点，然后中断遍历的时候，还需要考虑最后 root 节点
 * 8. 因为我们之前的逻辑是根据叶子节点状态来判断当前节点的更改的，所以 root 节点很可能会因为叶子节点是覆盖值而没有进行任何的设置，这个时候 root 就可能是 0，所以如果 root 是 0 的话，还得再安一个摄像头
 * 9. 我们最终的结果就是要保证整棵树的节点状态都不为 0即可
 * 10. 时间复杂度 ${O(n)}$
 */
var minCameraCover = function (root) {
  if (!root) return 0;
  let ret = 0; // 装了多少摄像头
  const dfs = (root) => {
    if (!root.left && !root.right) return; // 到达叶子节点，直接返回，不加摄像头
    if (root.left) dfs(root.left);
    if (root.right) dfs(root.right);
    // 后序遍历，遇到父子节点存在摄像头，那就不需要加了
    if ((root.left && root.left.val !== 0  || !root.left) && (root.right && root.right.val !== 0 || !root.right)){
        if((root.left && root.left.val === 1) || (root.right && root.right.val === 1)){
            // 存在摄像头才能波及
            root.val = 2 // 波及到的
        }
        return 
    }
    // 必须要保证存在的子节点都已经是 1 的时候，才可以放心继续往上走
    root.val = 1; //如果大家伙都没有装，那就我来装吧
    ret++;
  };
  dfs(root);
  return root.val === 0  ? ret+1 : ret 
};
