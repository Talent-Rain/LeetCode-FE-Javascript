<!--
 * @Author: your name
 * @Date: 2021-07-16 09:16:55
 * @LastEditTime: 2021-07-18 15:49:25
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /LeetCode-FE-Javascript/Code/并查集/并查集.md
-->
## [朋友圈](https://leetcode-cn.com/problems/number-of-provinces/solution/bing-cha-ji-by-jzsq_lyx-xu2r/)
### 题目
班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。

给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果 M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。

```javascript
示例 1：

输入：
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出：2
解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。
第2个学生自己在一个朋友圈。所以返回 2 。
示例 2：

输入：
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出：1
解释：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1 。


提示：

1 <= N <= 200
M[i][i] == 1
M[i][j] == M[j][i]
```

### 分析 -- 省份数量 --- 朋友圈是这道题的改写
- N 个独立的圈子逐渐收缩成 M 个范围更大的全局；
- 先构建一个长度为 N 的数组，下标和值同值；下标 index 表示学生 index，值 value 表示他与学生 value 是一个圈子的；如果 index 和 value 同值，那么证明他自己与自己构成一个朋友圈，初始情况确实如此。
- 每当遇到  isConnected[i][j] === 1 , 表示 i, j 同属于一个圈子，所以将他们的圈子关联 connect 起来
- connect 的过程可以理解为 a , b 找出他们带头大哥，然后将两个带头大哥相互认识的过程，所以先找，再连
- find 的过程是找出带头大哥的过程，也就是那个只活在自己内心世界中，大家都认识它，但它=他还是只认识他自己的人，属于圈子的核心人物，所以我们判断如果是自指向的，那么就是找到了，返回，否则不断递归查找
- 时间复杂度${O(N^2logN)}$ 其中 N 是人数，遍历二维数组就是 N*N，然后每一次遇到需要连接和查找操作，查找操作最多 N 次，多少 1 次，所以是 logN

```javascript
/*
 * @Author: your name
 * @Date: 2021-07-16 09:21:22
 * @LastEditTime: 2021-07-16 09:44:51
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /LeetCode-FE-Javascript/Code/并查集/2.547. 省份数量.js
 */
// 547. 省份数量 --- 题1是这道题的改写

/**
 * @分析 -- 并查集
 * 1. 构建一个自指向数组，最后结果也是根据自指向来判断有多少集合 -- 即有多少个根
 * 2. 遍历所有的节点，如果值为 1 ，则将节点所代表的集合合并成一个
 */
 var findCircleNum = function(isConnected) {
    const parent = Array.from(isConnected).map((item,index) => index) // 创建一个自指向的数组
    const len = isConnected.length;
    for(let i = 0;i<len;i++){
        for (let j = 0; j < len; j++) {
            if(isConnected[i][j]){
                // 将 i 和 j 所在的集合连接起来
                _connect(i,j)
            }
        }
    }
    return parent.filter((item,index)=>item === index).length
    function _connect(i,j) {
        // 先找出 i 和 j 对应的根节点，然后连接起来
        parent[_find(i)] = _find(j)
    }
    // 找出 i 的根节点
    function _find(i){
        if(parent[i] !== i){
            // 指向其他节点，并不是自指向 -- 根据当前父节点的下标继续找
            parent[i] = _find(parent[i])
        }
        // 这个时候已经是自指向了
        return parent[i]
    }

};

// 测试
console.log(findCircleNum([[1,1,0],[1,1,0],[0,0,1]]))
```



## [924. 尽量减少恶意软件的传播](https://leetcode-cn.com/problems/minimize-malware-spread/solution/bing-cha-ji-by-jzsq_lyx-ab5q/)

### 分析
- 先通过并查集，将关联的节点都汇聚到各自的 root 节点中
- 遍历 initial 病毒源，找出病毒源所属的集合 root，并用数组 injectedArr 保存集合 root 下病毒源的个数
- 如果集合下病毒源超出 2 个，那么即便删除其中 1 个，依然会再次感染，所以不考虑
- 如果集合下病毒源为 1 个，那么找出集合最多的那个集合，再找出引起这个集合 root 病变的最小的那个病毒源

```javascript
// 924. 尽量减少恶意软件的传播

 var minMalwareSpread = function(graph, initial) {
    const len = graph.length ; 
    // 构建并查集
    const uf = new UnionFind(len)
    for(let i = 0;i<len;i++){
        for(let j = 0;j<len;j++){
            if(graph[i][j]){
                uf.connect(i,j)
            }
        }
    }

    // 感染源节点在并查集中感染到的根节点数组
    const injectedArr = new Array(len).fill(0);

    initial.forEach(node => {
        // 初始感染节点会传递到并查集的根节点
        const root = uf.find(node)
        injectedArr[root]++
    }) 

    let maxSize = 0 // 最少是 0 个
    let ret = -1 // 返回的节点值
    // 遍历 initial, 找出初始感染节点能感染节点最多的哪一个；
    // 对于 injectedArr 中值，如果大于 1 ，证明初始感染源超过 1 个，那么即便删除其中一个，他还是会被另外的感染源再次感染
    // 对于值为 1, 首先比对感染的人数 -- 即这个并查集根节点下的子节点数 -- 如果一致的时候，取小的那个感染源值
    initial.forEach(node => {
        const root = uf.find(node)
        const count =injectedArr[root]
        if(count === 1 ){
            const size = uf.sizes[root]
            if(size >maxSize || (size === maxSize && node<ret)){
                ret = node,
                maxSize = size
            }
        }
    })

    // 如果是 ret === -1 ，表明随便删除一个节点，得到的结果都一样，这个时候要返回索引最小的节点，这里的索引最小指 initial 中值最小的节点
    if (ret == -1) return Math.min(...initial)
    return ret

};

class UnionFind {
    constructor(size){
        // 用下标表示节点本身，值表示连接的节点，初始化的时候都是自连接
        this.parents = Array.from({length:size}).map((_,index) => index)
        // 用下标表示节点本身，值为作为根节点时，挂在自己下的节点数，默认情况就是挂了自己，所以是 1
        this.sizes = new Array(size).fill(1);
    }

    //  查找节点 x 的根节点
    find(x){
        if(x!== this.parents[x]){
            this.parents[x] = this.find(this.parents[x])
        }
        return this.parents[x]
    }

    connect(x,y){
        const fx = this.find(x)
        const fy = this.find(y)
        if(fx === fy) return 
        if(this.sizes[fx]>this.sizes[fy]){
            // 如果连接 fx 的节点更多，那么就让 fy 指向 fx
            this.parents[fy] = fx
            this.sizes[fx] += this.sizes[fy]
        }else{
            this.parents[fx] = fy
            this.sizes[fy] += this.sizes[fx]
        }
    }
}
```

## [1319. 连通网络的操作次数](https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/solution/bing-cha-ji-by-jzsq_lyx-fuc9/)
### 分析
1. 如果连接线小于 n-1，则肯定失败，直接返回 —1 即可
2. 用并查集将 n 个网络根据 connections 连接成集合，查看总共有几个集合
3. 如果刚好是 1 个，则不用拨动，返回 -1；否则返回 k-1 个

```javascript
// 1319. 连通网络的操作次数

/**
 * @分析
 * 1. 如果连接线小于 n-1，则肯定失败，直接返回 —1 即可
 * 2. 用并查集将 n 个网络根据 connections 连接成集合，查看总共有几个集合
 * 3. 如果刚好是 1 个，则不用拨动，返回 -1；否则返回 k-1 个
 */
 var makeConnected = function (n, connections) {
    const len = connections.length; // 连接线数量
    if (len < n - 1) return - 1;
    // 创建并查集
    const uf = new UnionFind(n)
    connections.forEach(([x,y]) =>{
      uf.connect(x,y)
    })
    const ufSize = uf.sizes
    return ufSize-1
  };
  
  class UnionFind {
    constructor(sizes) {
      this.father = Array.from({ length: sizes }).map((_, index) => index);
      this.sizes = sizes
    }
  
    find(x) {
      if (x !== this.father[x]) {
        this.father[x] = this.find(this.father[x]);
      }
      return this.father[x];
    }
    connect(x,y){
        let cx = this.find(x)
        let cy = this.find(y)
        if(cx === cy) return 
        this.father[cx] = cy
        this.sizes-- 
    }
  }
  
```