<!--
 * @Author: your name
 * @Date: 2021-07-16 09:16:55
 * @LastEditTime: 2021-07-16 10:01:07
 * @LastEditors: your name
 * @Description: In User Settings Edit
 * @FilePath: /LeetCode-FE-Javascript/Code/并查集/并查集.md
-->
## [朋友圈](https://leetcode-cn.com/problems/number-of-provinces/solution/bing-cha-ji-by-jzsq_lyx-xu2r/)
### 题目
班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。

给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果 M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。

```javascript
示例 1：

输入：
[[1,1,0],
 [1,1,0],
 [0,0,1]]
输出：2
解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。
第2个学生自己在一个朋友圈。所以返回 2 。
示例 2：

输入：
[[1,1,0],
 [1,1,1],
 [0,1,1]]
输出：1
解释：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1 。


提示：

1 <= N <= 200
M[i][i] == 1
M[i][j] == M[j][i]
```

### 分析 -- 省份数量 --- 朋友圈是这道题的改写
- N 个独立的圈子逐渐收缩成 M 个范围更大的全局；
- 先构建一个长度为 N 的数组，下标和值同值；下标 index 表示学生 index，值 value 表示他与学生 value 是一个圈子的；如果 index 和 value 同值，那么证明他自己与自己构成一个朋友圈，初始情况确实如此。
- 每当遇到  isConnected[i][j] === 1 , 表示 i, j 同属于一个圈子，所以将他们的圈子关联 connect 起来
- connect 的过程可以理解为 a , b 找出他们带头大哥，然后将两个带头大哥相互认识的过程，所以先找，再连
- find 的过程是找出带头大哥的过程，也就是那个只活在自己内心世界中，大家都认识它，但它=他还是只认识他自己的人，属于圈子的核心人物，所以我们判断如果是自指向的，那么就是找到了，返回，否则不断递归查找
- 时间复杂度${O(N^2logN)}$ 其中 N 是人数，遍历二维数组就是 N*N，然后每一次遇到需要连接和查找操作，查找操作最多 N 次，多少 1 次，所以是 logN

```javascript
/*
 * @Author: your name
 * @Date: 2021-07-16 09:21:22
 * @LastEditTime: 2021-07-16 09:44:51
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /LeetCode-FE-Javascript/Code/并查集/2.547. 省份数量.js
 */
// 547. 省份数量 --- 题1是这道题的改写

/**
 * @分析 -- 并查集
 * 1. 构建一个自指向数组，最后结果也是根据自指向来判断有多少集合 -- 即有多少个根
 * 2. 遍历所有的节点，如果值为 1 ，则将节点所代表的集合合并成一个
 */
 var findCircleNum = function(isConnected) {
    const parent = Array.from(isConnected).map((item,index) => index) // 创建一个自指向的数组
    const len = isConnected.length;
    for(let i = 0;i<len;i++){
        for (let j = 0; j < len; j++) {
            if(isConnected[i][j]){
                // 将 i 和 j 所在的集合连接起来
                _connect(i,j)
            }
        }
    }
    return parent.filter((item,index)=>item === index).length
    function _connect(i,j) {
        // 先找出 i 和 j 对应的根节点，然后连接起来
        parent[_find(i)] = _find(j)
    }
    // 找出 i 的根节点
    function _find(i){
        if(parent[i] !== i){
            // 指向其他节点，并不是自指向 -- 根据当前父节点的下标继续找
            parent[i] = _find(parent[i])
        }
        // 这个时候已经是自指向了
        return parent[i]
    }

};

// 测试
console.log(findCircleNum([[1,1,0],[1,1,0],[0,0,1]]))
```